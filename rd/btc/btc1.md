# 比特币白皮书中译版v1
### 比特币：一个点对点的电子现金系统

Satoshi Nakamoto  
[satoshin@gmx.com](mailto:satoshin@gmx.com)  
[www.bitcoin.org](http://www.bitcoin.org)  

　　摘要：一个纯粹的点对点的电子现金系统应该允许以在线的方式直接从一方转账到另一方而不需要通过金融机构。数字签名可提供部分解决方案，但是如果依然通过受信任的第三方来确保不发生重复支付的话，主要的优势就会消失。我们打算通过一个点对点的系统来解决重复支付的问题。网络交易的时间戳的散列形成了一个基于哈希算法的工作量证明的连续不断的链，形成了一个只有通过重做所有的工作量证明才能篡改的记录。最长的链不仅作为证明事件顺序的证据，也证明它来自最大的CPU算力池。只要大部分的CPU算力还被那些没有联合起来攻击网络的节点控制，它们将产生最长的链并超过黑客。网络本身需要最小的结构。消息以尽最大努力的方式进行广播，任意节点可以随时加入或者离开网络，接受最长的基于工作量证明的链作为它们离开时所发生事情的证明。

(1) 引言  
　　互联网上的商业行为越来越依赖于金融机构作为唯一的可信第三方来处理电子支付。尽管对于大部分的交易都处理的足够好，但是依然无法摆脱基于信任的模型的固有弱点。完全不可逆的交易是不可能的，因为金融机构不能避免调解纠纷。调解成本推高了交易成本，限制了实际交易的最小规模，并且切断了为小的随意交易提供支持的可能性，并且更大的成本损失是失去了为不可逆服务提供不可逆支付的可能性。因为交易被篡改的可能性存在，所以信任是被广泛要求的。商人必须警惕他们的顾客，要求顾客提供比他们原本需要的更多的信息。一定比例的欺诈被认为是不可避免的。这些花费和付款的不确定性可以通过使用实物货币来避免，但是在没有可信任方的通信通道中，没有一种机制来保证交易是否可靠。  
　　在一个电子支付系统中，需要的是使用密码验证而不是信任，允许任何想要进行交易的当事人在他们之间进行直接的交易而不需要一个可信任的第三方机构。通过计算的方式确保无法篡改的交易可以保护卖家免受欺诈，而日常代管机制可以很容易的实施以保护买家。在本文中，我们提出了一个解决方案，使用点对点的分布式时间戳服务器来生成按时间顺序排列的交易的计算证明来解决双支问题。只要所有诚实节点的总CPU算力大于所有攻击节点的总CPU算力，系统就是安全的。

(2) 交易  
　　我们将电子货币定义为数字签名链。每一个币的拥有者通过对前一个交易和下一个拥有者的公钥进行哈希数字签名并将这个信息添加到币的末尾来将这个币转让给下一个拥有者。收款者可以通过验证签名的方式验证这个链的所有权。  

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-1.png?raw=true)  

<div align=left>

　　当然，问题是收款者不能验证币的拥有者是否“双花”了这个币。一个通用的解决方案是引入一个可信的中央权威机构或者铸币厂，通过它来检查每一笔交易是否存在“双花”行为。每一次交易时，币必须返回铸币厂并且发行一个新币，并且只有铸币厂发行的新币才被确认是没有被“双花”的。这个解决方案的问题是整个金融系统的命运依赖于运维这个铸币厂的公司，并且所有的交易必须通过他们，这很像一个银行。  
　　我们需要一种方式让收款者知道前一个币的拥有者没有签名任何更早的交易。就我们的目的而言，最早的交易是最重要的，所以我们不关心后面是否尝试进行“双花”。确认没有交易被遗漏的唯一方法是知道所有的交易。在基于铸币厂的模型中，铸币厂知道所有的交易并且决定哪一个交易先到达。为了在没有可信第三方的情况下实现这一目标，所有交易必须公开[1]，并且我们需要一个系统来帮助参与者共同确定一个所有接收到的交易的唯一历史顺序。收款者需要证明在每次交易的时候，主要的节点同意这是他们收到的第一次交易。

(3) 时间戳服务器  
　　我们提出的解决方案是以时间戳服务器开始的。时间戳服务器以对一组交易信息哈希值设置时间戳并且广泛的发布这个哈希值的方式进行工作，就像在报纸上或者新闻组的帖子上[2-5]。时间戳证明，在那个时刻数据是存在的，显然是为了加入到这个哈希值里面。每一个时间戳包含前一个时间戳在它的哈希值里面，构建了一个链，每一个增加的时间戳都会增强前一个时间戳。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-2.png?raw=true)  

<div align=left>

(4) 工作量证明  
　　为了在点对点的基础上实现一个分布式时间戳服务器，我们将需要使用一个和Adam Back‘s Hashcash[6]类似的工作量证明系统，来取代报纸或者新闻组帖子。工作量的证明涉及到使用某种算法扫描一个值的哈希值，例如SHA-256算法，这个哈希值是以一定数量的0开头的。所需的平均工作量随着0的个数的增加而成指数级增长，并且可以通过执行单一的哈希运算进行验证。  
　　对于我们的时间戳网络而言，我们通过为新块找到一个符合所需0的位数的哈希值才产生这个新块的方式来实现工作量证明机制。一旦CPU的工作被证明了满足工作量证明的条件，这个块将不可能被改写除非重做这个块之后的所有工作。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-3.png?raw=true)  

<div align=left>

　　工作量证明也解决了多数决策中的代表性问题。如果多数是基于一个IP地址一票的话，那么它就很容易被任何一个能够分配多个IP地址的人破坏。工作量证明机制本质上是一CPU一票。多数的选择代表了最长的链，同时也是最大的工作量投入的证明。如果CPU算力中的大部分被诚实的节点控制，诚实链的增长速度将是最快的，它将超过所有的与之竞争的其他链。要修改过去已经存在的块，黑客必须重做这个块及其后所有块的工作量证明，并且刚上并且超越诚实节点的工作。稍后我们将展示，一个较慢的黑客成功追赶的概率随着后续块的增加而成指数衰减。  
　　为了平衡随时间推移不断增长的硬件速度和运行节点个各种利害关系，工作量证明的难度是以每小时生成平均块数的移动平均值来确定的。如果他们生成的太快，难度将增加。

(5) 网络  
　　运行网络需要下面的步骤：  
　　1） 新的交易被广播到所有节点  
　　2） 每一个节点都将这个新的交易包含到一个区块中  
　　3） 每一个节点都为区块寻找一个符合要求的哈希值来进行工作量的证明  
　　4） 一旦某个节点发现了这个符合要求的哈希值，它将把这个区块广播到所有的节点  
　　5） 只有当所有的交易都是有效的，并且没有被花掉，节点才会接受它  
　　6） 节点以继续在链上创建新区块的方式来表名它接受了这个心的区块，并将这个区块的哈希值作为新区块的前置哈希值  
　　节点总是认为最长的链是正确的，并在这个链的基础上进行链接新的区块以扩展它。如果两个节点同时广播了下一个区块的不同版本，一些节点先收到其中一个而另外的节点先收到另一个。在这种情况下，他们在接受到的第一个节点上开始工作，但是同时也保留另外一个，因为有可能它会变得更长。当下一个区块被发现时，其中一个链将变得更长，这种平衡被打破；在另外一条链上工作的节点会切换到这条更长的链上。  
　　新交易的广播没有必要一定要到达所有的节点。只要它们能到达大多数节点，不就它们就会百包含在区块中。区块的广播同样允许信息的丢失。当一个节点没有收到一个区块，他会在收到下一个区块时意识到这一点而请求它。

(6) 动机  
　　按照惯例，区块里的交易是一个特殊的交易，它开始了一个被这个区块的创建者所拥有的新币。这对激励节点支持网络有促进作用，并且提供了一种初始的方式来增加货币的发行量，因为没有中央权威机构（一般意义而言就是各国的央行）来发行他们。不断增加固定数量的新币类似于矿工消耗资源来增加黄金的发行量。在我们这里，消耗的是CPU的时间和电力。  
　　激励机制也可以通过收取交易费的方式长期起作用。如果输出值小于输入值，那么这个差额就作为包含这个交易的区块的交易手续费（也就是说，找到一个新区块可以通过两种方式获利：1. 找到区块的奖励； 2. 这个区块所包含交易的手续费——至少在发行的比特币总数量小于2100万以前是这样）。一旦预定数量的比特币进入流通，激励机制就可以完全过渡到交易手续费，并且完全没有通货膨胀。  
　　这样的激励机制或许有助于鼓励节点保持诚实。如果一个贪婪的黑客能够控制比所有的诚实节点加起来都多的CPU算力，他必须做出选择：使用这些算力来诈骗——把已经付出去的钱偷回来，还是用这些算力来产生新的比特币。他应该能够发现按照规则办事能让他获得更多的利润，因为规则允许他获得比其他所有人加起来的总和还要多的比特币，这比破坏整个系统和他自己财富的合法性要好的多。

(7) 回收磁盘空间  
　　一个比特币中的最后一个交易被足够多的区块确认后，再次之前的消费交易就可以被删除以释放磁盘空间。为了不破坏区块的哈希值，交易信息的哈希值存储在Merkle树中[7][2][5]，只有根哈希值包含在了区块的哈希值中。通过截断树的分支的方式，老的区块可以被压缩。内部的哈希值不需要被存储。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-4.png?raw=true)  

<div align=left>

　　一个区块的头部数据在没有交易数据的情况下大约是80字节。如果我们假设每10分钟产生一个区块，80字节*6*24*365=4.2兆每年。以2008年为例，在市场上出售的计算机一般都有2G的内存，摩尔定律预测这个值以每年1.2G的速度增长，所以即使区块头必须保存在内存中也不会有任何问题。

(8) 简单支付验证  
　　在一个不完整的网络节点上进行支付验证是可行的。用户只需要保留最长的工作量证明链的区块头的副本，这个链可以通过查询网络节点来获得，直到他确信他获得了最长的链，并且获得Merkle树的分支来链接交易和与之时间戳相同的区块。他不能自己检查这个交易，但是通过链接它到链上的某一位置，他可以看到一个网络节点接受了它，并且加在它后面的区块进一步确认了网络已经接受了它。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-5.png?raw=true)  

<div align=left>

　　只要诚实节点控制网络，这样的验证就是可靠的，但是如果黑客控制了网络，这样的验证就很脆弱了。因为网络节点可以自己验证交易，所以这种简单验证方法可以被黑客伪造的交易数据所欺骗，直到黑客不能再控制网络。防止这种情况的一种策略是，当检测到无效的区块时，接收来自网络节点的警告，提醒用户的客户端软件下载完整的区块，并且警惕这些交易以确认它的不一致性。那些频繁接收付款的企业可能仍希望运行在自己的节点上以获得更独立的安全性和更快的验证。

(9) 价值的组合与分割  
　　虽然单独地处理比特币是可能的，但是在转账过程中每一分钱都进行单独交易是不明智的。为了允许币值被分割和合并，交易可以吧包含多个输入和输出。通常情况下，有一个从较大的、从前置交易来的单一的输入，或者合并多个金额比较小的输入，并且大多都有两个输出：一个是这次支付本身，另外一个是找零，如果有的话，返回给汇款者。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-6.png?raw=true)  

<div align=left>

　　应该注意的是扇出，其中一个交易依赖于几个交易，而这些交易依赖更多的交易，这不是问题。永远不需要提取一个交易历史记录的完整独立拷贝。

(10) 隐私  
　　传统银行模型通过对相关方和可信第三方的信息访问控制来实现隐私保护。公开所有交易的必要性排除了这种方法，但是隐私仍然可以通过截断信息流的某一环节的方式得到保护：保持公钥的匿名性。公众可以看到有人向其他人转账，但是没有任何信息把这个交易和任何人联系起来。这有点类似于证券交易所发布信息，有某个交易的时间和金额，即“磁带”，是公开的，但是没有说明交易的双方是谁。

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-7.png?raw=true)  

<div align=left>

　　作为一个附加的防火墙，在每次交易中都采用新的密钥对，以防止它们被链接到一个共同的拥有者。因为多输入交易的存在，有一些链接是不可避免的，这必然表明这些输入时属于同一个拥有者。风险在于，一旦秘钥的拥有者被披露，链接可以揭示属于同一拥有者的其他交易。

(11) 计算  
　　我们假设这样一个场景：黑客试图以更快的方式生成一个代替诚实链的替换链。即使这样的情况出现，也不代表系统可以被任意更改，比如凭空创造币值，或者拿本来不属于黑客的钱。节点不会接收一个无效的交易作为一次支付，并且一个诚实节点永远都不会接受一个包含无效交易的区块。黑客只能尝试改变他自己的交易，收回他最近花的钱。  
　　诚实链和黑客伪造链之间的竞争可以描述为二项式随机漫步。成功的事件是诚实链上增加了一个区块，其领先率增加一个区块，失败事件是黑客在伪造链上增加了一个区块，他和诚实链之间的差距减少一个区块。  
　　黑客在给定落后区块数的情况下成功追上诚实链的概率类似于赌徒的破产问题。假设一个赌徒在开始的时候有负债，但是他有无上限的信贷资格，并且可以无限次数的尝试，试图达到盈亏平衡。我们可以计算出他达到盈亏平衡的概率，或者黑客成功追上诚实链的概率[8]：  
　　p=诚实链找到下一个区块的概率  
　　q=黑客在伪造链上找到下一个区块的概率  
　　qz=黑客在落后z区块后成功追上诚实链的概率  

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-8.png?raw=true)  

<div align=left>

　　假设p>q，黑客成功的概率随着必须要追赶上的区块的个数程指数级下降。对他不利的是，如果他一开始不能幸运的冲到前面去，他的机会就会变的很渺茫，因为他落后了。  
　　现在让我们考虑下，一个交易的接收者需要多长时间才能充分确认发送者不可能修改这个交易。我们假设交易的发起者是一名黑客，他想让交易的接收者相信他已经支付了一段时间之后，再将这笔钱转回给自己。当这种情况发生时，接收者会被提醒，但是发送者希望这已经为时已晚了。  
　　接收者生成新的密钥对，并在签名前向发送方提供公钥。这就阻止了发送者通过连续不断的工作来提前准备一个长的区块链，直到他足够幸运地到达了足够远的位置，然后在那时发起交易。一旦交易被发送，黑客就开始秘密地在包含另外一个交易版本的并行区块链上进行工作。  
　　交易的接收者等待直到这个交易被包含在了某一区块中，并且后面被链接了z个区块。他不知道黑客确切的工作进度，但是假设诚实的区块需要平均的预期时间，黑客的潜在进展将是根据预期值的泊松分布。  

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-9.png?raw=true)  

<div align=left>

　　为了得到攻击者仍然能够赶上的概率，我们将泊松密度乘以他能从那一点赶上的概率所获得的每一个进展量：

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-10.png?raw=true)  

<div align=left>

　　重新排列以避免对无限的分布的尾部进行求和…  

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-11.png?raw=true)  

<div align=left>

　　转换成C代码：

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-12.png?raw=true)  

<div align=left>

　　运行一些结果，我们可以看到概率随z的值程指数级下降：

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-13.png?raw=true)  

<div align=left>

　　P小于0.1%的求解：

<div align=center>

![刘心泉说](https://github.com/unetman/works/blob/master/resources/btc1-14.png?raw=true)  

<div align=left>

(12) 结论  
　　我们提出了一个不依赖于信任的电子交易系统。我们从通常的数字签名货币框架开始，它提供了对所有权的有力控制，但它是不完备的，因为没有办法阻止双重支付。为了解决这个问题，我们提出了一个点对点的网络使用工作量证明的方式来记录一个完全公开的交易历史，当大部分的CPU算力被诚实节点控制时，黑客的攻击行为将很快变得从计算角度看完全不切合实际。网络因其非结构化的简单性而健壮。所有节点同时在几乎很少协调的情况下工作。他们不需要被识别，因为消息不被路由到任何特定的地方，并且只需要在尽力而为的基础上传递即可。节点可以随意的离开和重新加入网络，接受基于工作量证明的区块链作为他们不在是所发生事情的证据。他们使用算力进行投票，以继续在这个区块后进行扩展的方式表示接受这个区块，以不在这个区块后进行扩展的方式表示拒绝接受这个无效的区块。任何需要的规则和激励都可以通过这种共识机制加强。

**参考文献**  
[1] W. Dai, “b-money,” http://www.weidai.com/bmoney.txt, 1998.  
[2] H. Massias, X.S. Avila, and J.-J. Quisquater, "Design of a secure timestamping service with minimal trust requirements," In 20th Symposium on Information Theory in the Benelux, May 1999.  
[3] S. Haber, W.S. Stornetta, "How to time-stamp a digital document," In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991.  
[4] D. Bayer, S. Haber, W.S. Stornetta, "Improving the efficiency and reliability of digital time-stamping," In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.  
[5] S. Haber, W.S. Stornetta, "Secure names for bit-strings," In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997.  
[6] A. Back, "Hashcash - a denial of service counter-measure," http://www.hashcash.org/papers/hashcash.pdf, 2002.  
[7] R.C. Merkle, "Protocols for public key cryptosystems," In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.  
[8] W. Feller, "An introduction to probability theory and its applications," 1957.


2018-05-11  
北京
